/*
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/
 */
package org.phenotips.studies.family.internal;

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang3.StringUtils;

/**
 * Tools for updating the SVG generated by the pedigree.
 *
 * @version $Id$
 * @since 1.2RC1
 */
public final class SvgUpdater
{
    // matches SVG links to patients, such as href="/bin/data/P0000001"
    private static final Pattern PATIENT_PAGE_LINK_PATTERN = Pattern.compile("href=\"[\\w\\/]*?/(P\\d+)");

    private static final String STROKE_ATTR_TOKEN = "stroke-width=\"";

    /**
     * The number of pixels to shift text when a link is removed.
     */
    private static final int SVG_LINK_HEIGHT_IN_PIXELS = 22;

    private SvgUpdater()
    {
    }

    /**
     * Sets svg width to the given value. If value <= 0 it is ignored and the same svg is returned.
     * @param svg a string representing an svg
     * @param width target width in pixels
     * @return svg with width changed
     */
    public static String setSVGWidth(String svg, int width)
    {
        if (width <= 0 || svg == null) {
            return svg;
        }
        String updatedSvg = svg.replaceFirst("(<svg[^>]+)width=\"\\d+\"", "$1width=\"" + width + '"');
        return updatedSvg;
    }

    /**
     * Sets svg height to the given value. If value <= 0 it is ignored and the same svg is returned.
     * @param svg a string representing an svg
     * @param height target height in pixels
     * @return svg with height changed
     */
    public static String setSVGHeight(String svg, int height)
    {
        if (height <= 0 || svg == null) {
            return svg;
        }
        String updatedSvg = svg.replaceFirst("(<svg[^>]+)height=\"\\d+\"", "$1height=\"" + height + '"');
        return updatedSvg;
    }

    /**
     * Removes an HTML link and label for the given patient from the SVG.
     *
     * @param svg can not be null
     * @param removePatientId id of the link to be removed
     * @return SVG with `<a></a>` corresponding to patient record cut out
     */
    public static String removeLink(String svg, String removePatientId)
    {
        List<SvgElementHolder> links = SvgUpdater.findAndParseAllElements(svg, new SvgLinkParser(removePatientId));
        String svgWithNoLink = SvgUpdater.applyActionToSvg(svg, links.iterator(), new SvgRemoveAction());

        Iterable<SvgElementHolder> labels = SvgUpdater.findAndParseAllElements(svgWithNoLink, new SvgTextParser(links));
        // shift up labels below the link after removing the link
        labels = SvgUpdater.shiftSvgElements(labels, -SvgUpdater.SVG_LINK_HEIGHT_IN_PIXELS);
        String updatedSvg = SvgUpdater.applyActionToSvg(svgWithNoLink, labels.iterator(), new SvgUpdateAction());

        return updatedSvg;
    }

    private static List<SvgElementHolder> findAndParseAllElements(String svg, SvgElementParser parser)
    {
        // TODO: replace by some SVG/XML library, e.g. https://xmlgraphics.apache.org/batik/

        List<SvgElementHolder> elementList = new LinkedList<SvgElementHolder>();

        try {
            String remainingSvg = svg;
            int potentialStart;
            // the index of the opening tag, so that we know which closing tag to look for
            int selectedTag;
            int offsetFromSvgStart = 0;
            int testStart = 0;
            while (testStart != -1) {
                potentialStart = remainingSvg.length();
                selectedTag = 0;
                int tagIndex = 0;
                for (String tagOpen : parser.getSvgTagOpen()) {
                    testStart = remainingSvg.indexOf(tagOpen);
                    if (testStart != -1 && testStart <= potentialStart) {
                        potentialStart = testStart;
                        selectedTag = tagIndex;
                    }
                    tagIndex++;
                }

                int potentialEnd = remainingSvg.indexOf(parser.getSvgTagClosed().get(selectedTag));
                if (potentialEnd != -1) {
                    int nextSubstringStart = potentialEnd + parser.getSvgTagClosed().get(selectedTag).length();
                    parser.iterativeAdd(potentialStart, svg, offsetFromSvgStart, nextSubstringStart, elementList);
                    remainingSvg = remainingSvg.substring(nextSubstringStart);
                    offsetFromSvgStart += nextSubstringStart;
                } else {
                    // TODO: throw an error if end is not found?
                    break;
                }
            }
        } catch (Exception ex) {
            // TODO: throw?
        }
        return elementList;
    }

    private static SvgElementHolder findProbandShape(Iterable<SvgElementHolder> elements)
    {
        for (SvgElementHolder shape : elements) {
            if (shape.belongsToProband) {
                return shape;
            }
        }
        return null;
    }

    private static SvgElementHolder findShapeWithNodeId(Iterable<SvgElementHolder> elements, String nodeId)
    {
        for (SvgElementHolder shape : elements) {
            if (shape.nodeId.equalsIgnoreCase(nodeId)) {
                return shape;
            }
        }
        return null;
    }

    private static Iterable<SvgElementHolder> shiftSvgElements(Iterable<SvgElementHolder> elements, int shiftBy)
    {
        for (SvgElementHolder element : elements) {
            int startYPosition = element.content.indexOf(" y=\"");
            if (startYPosition != -1) {
                // accounting for length of ` y="`
                startYPosition += 4;
                int endYPosition = element.content.indexOf('"', startYPosition + 1);
                String yPositionString = element.content.substring(startYPosition, endYPosition);
                double yPosition = Double.parseDouble(yPositionString);

                Double newYPosition = yPosition + shiftBy;
                element.content = element.content.substring(0, startYPosition) + newYPosition.toString()
                    + element.content.substring(endYPosition);
            }
        }
        return elements;
    }

    /**
     * Replaces parts of SVG that are stored in the provided element list with the appropriately modified parts.
     *
     * @param elements must be a deterministic iterator, returning links in order that they occur in the svg
     * @param svg must not be null
     * @return modified svg
     */
    private static String applyActionToSvg(String svg, Iterator<SvgElementHolder> elements, SvgAction action)
    {
        String parsedSvg = "";
        int splitHead = 0;
        SvgElementHolder holder;
        while (elements.hasNext()) {
            holder = elements.next();
            parsedSvg += svg.substring(splitHead, holder.startPosition);
            parsedSvg += action.getReplacement(holder);
            splitHead = holder.endPosition;
        }
        parsedSvg += svg.substring(splitHead);
        return parsedSvg;
    }

    /**
     * Processes the SVG to visually mark a patient with current patient style.
     *
     * @param svg can not be null
     * @param patientId the id of the patient that should be visually marked as current
     * @return svg with the style for current patient applied to the node with id `currentUserId` and proband style
     *         retained
     */
    public static String setCurrentPatientStylesInSvg(String svg, String patientId)
    {
        List<SvgElementHolder> nodeShapes = SvgUpdater.findAndParseAllElements(svg, new SvgNodeShapeParser());

        // not ideal, but will likely work fine for a long time - removing stroke from every shape
        SvgUpdater.removeStrokeWidth(nodeShapes);

        SvgElementHolder probandShape = SvgUpdater.findProbandShape(nodeShapes);
        if (probandShape != null) {
            addProbandStyle(probandShape);
        }

        List<SvgElementHolder> links = SvgUpdater.findAndParseAllElements(svg, new SvgLinkParser(patientId));
        if (links.size() == 1) {
            // TODO: not sure what to do if more than one link to the same patient ID
            SvgElementHolder currentShape = SvgUpdater.findShapeWithNodeId(nodeShapes, links.get(0).nodeId);
            if (currentShape != null) {
                addCurrentPatientStyle(currentShape);
            }
        }

        String updatedSvg = SvgUpdater.applyActionToSvg(svg, nodeShapes.iterator(), new SvgUpdateAction());
        return updatedSvg;
    }

    private static void removeStrokeWidth(Iterable<SvgElementHolder> shapes)
    {
        for (SvgElementHolder shape : shapes) {
            int styleStart = shape.content.indexOf(STROKE_ATTR_TOKEN);
            int styleEnd = shape.content.indexOf('"', styleStart + STROKE_ATTR_TOKEN.length());
            // should throw an error if end is not found, but we are trying to make sure no data is lost
            if (styleStart != -1 && styleEnd != -1) {
                shape.content = shape.content.substring(0, styleStart) + shape.content.substring(styleEnd + 1);
            }
        }
    }

    /**
     * @param probandShapes usually will be only one, or none
     */
    private static void addProbandStyle(SvgElementHolder probandShape)
    {
        SvgUpdater.setStrokeWidth(probandShape, 2);
    }

    /**
     * @param currentPatientShapes usually will be only one, or none
     */
    private static void addCurrentPatientStyle(SvgElementHolder currentPatientShape)
    {
        SvgUpdater.setStrokeWidth(currentPatientShape, 5);
    }

    private static SvgElementHolder setStrokeWidth(SvgElementHolder element, double width)
    {
        if (element.content.contains(STROKE_ATTR_TOKEN)) {
            int tokenStart = element.content.indexOf(STROKE_ATTR_TOKEN);
            int tokenEnd = element.content.indexOf('"', tokenStart + STROKE_ATTR_TOKEN.length());
            element.content = element.content.substring(0, tokenStart + STROKE_ATTR_TOKEN.length()) + width + element
                .content.substring(tokenEnd);
        } else {
            int closingBracketPos = element.content.indexOf('>');
            element.content = element.content.substring(0, closingBracketPos) + " " + STROKE_ATTR_TOKEN + width + '"'
                + element.content.substring(closingBracketPos);
        }
        return element;
    }

    private static class SvgElementHolder
    {
        private int startPosition;

        /**
         * Includes the entire closing tag.
         */
        private int endPosition;

        private int nodeIdTokenStart;

        private String content;

        private String patientId = "";

        private String nodeId = "";

        /**
         * Could be false even if it does. Must be synchronized with elements that automatically have this property
         * assigned.
         */
        private boolean belongsToProband;
    }

    private static class SvgLinkParser extends AbstractSvgElementParser
    {
        private String filterPatientId;

        SvgLinkParser(String patientId)
        {
            this.filterPatientId = patientId;
        }

        @Override
        public List<String> getSvgTagOpen()
        {
            List<String> list = new LinkedList<>();
            Collections.addAll(list, "<a");
            return list;
        }

        @Override
        public List<String> getSvgTagClosed()
        {
            List<String> list = new LinkedList<>();
            Collections.addAll(list, "</a>");
            return list;
        }

        @Override
        protected String getNodeIdTokenStartString()
        {
            return PEDIGREE_NODE_ID;
        }

        @Override
        public boolean test(String testPiece)
        {
            return testPiece.contains(PEDIGREE_NODE_ID);
        }

        @Override
        public boolean testHolder(SvgElementHolder holder)
        {
            if (filterPatientId == null) {
                return true;
            }
            return filterPatientId.equalsIgnoreCase(holder.patientId);
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder)
        {
            try {
                holder.patientId = parsePatientIdFromLink(holder);
            } catch (Exception ex) {
                // can't do anything
            }
        }

        private String parsePatientIdFromLink(SvgElementHolder link)
        {
            Matcher linkMatch = PATIENT_PAGE_LINK_PATTERN.matcher(link.content);
            if (linkMatch.find()) {
                return linkMatch.group(1);
            }
            return "";
        }
    }

    private static class SvgNodeShapeParser extends AbstractSvgElementParser
    {
        private static final String TEXT_ID_TOKEN_START = "node-shape-";

        @Override
        public List<String> getSvgTagOpen()
        {
            List<String> list = new LinkedList<>();
            Collections.addAll(list, "<rect", "<circle");
            return list;
        }

        @Override
        public List<String> getSvgTagClosed()
        {
            List<String> list = new LinkedList<>();
            Collections.addAll(list, "</rect>", "</circle>");
            return list;
        }

        @Override
        protected String getNodeIdTokenStartString()
        {
            return TEXT_ID_TOKEN_START;
        }

        @Override
        public boolean test(String testPiece)
        {
            return testPiece.contains(TEXT_ID_TOKEN_START);
        }

        @Override
        public boolean testHolder(SvgElementHolder holder)
        {
            return true;
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder)
        {
            holder.belongsToProband = holder.content.contains("isProband=\"true\"");
        }
    }

    private static class SvgTextParser extends AbstractSvgElementParser
    {
        private List<SvgElementHolder> filterByNodeId;

        SvgTextParser(List<SvgElementHolder> nodeList)
        {
            this.filterByNodeId = nodeList;
        }

        @Override
        public List<String> getSvgTagOpen()
        {
            List<String> list = new LinkedList<>();
            Collections.addAll(list, "<text");
            return list;
        }

        @Override
        public List<String> getSvgTagClosed()
        {
            List<String> list = new LinkedList<>();
            Collections.addAll(list, "</text>");
            return list;
        }

        @Override
        protected String getNodeIdTokenStartString()
        {
            return PEDIGREE_NODE_ID;
        }

        @Override
        public boolean test(String testPiece)
        {
            return testPiece.contains(PEDIGREE_NODE_ID);
        }

        @Override
        public boolean testHolder(SvgElementHolder holder)
        {
            if (this.filterByNodeId == null) {
                return true;
            }
            for (SvgElementHolder element : this.filterByNodeId) {
                if (holder.nodeId.equalsIgnoreCase(element.nodeId)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        protected void performAdditionalOperations(SvgElementHolder holder)
        {
            // the pedigree no longer puts the node id into the class name (??)
        }
    }

    private abstract static class AbstractSvgElementParser implements SvgElementParser
    {
        protected static final String PEDIGREE_NODE_ID = "pedigreeNodeID=\"";

        @Override
        public abstract List<String> getSvgTagOpen();

        @Override
        public abstract List<String> getSvgTagClosed();

        protected abstract String getNodeIdTokenStartString();

        @Override
        public abstract boolean test(String testPiece);

        @Override
        public abstract boolean testHolder(SvgElementHolder holder);

        protected abstract void performAdditionalOperations(SvgElementHolder holder);

        @Override
        public void iterativeAdd(int start, String svg, int offset, int nextSubstringStart,
            List<SvgElementHolder> elementList)
        {
            int absoluteStart = start + offset;
            int absoluteEnd = nextSubstringStart + offset;
            String content = svg.substring(absoluteStart, absoluteEnd);
            if (this.test(content)) {
                SvgElementHolder holder = this.createBasicHolder(absoluteStart, absoluteEnd, content);
                this.performAdditionalOperations(holder);
                if (this.testHolder(holder)) {
                    elementList.add(holder);
                }
            }
        }

        private SvgElementHolder createBasicHolder(int start, int end, String content)
        {
            SvgElementHolder holder = new SvgElementHolder();
            holder.startPosition = start;
            holder.endPosition = end;
            holder.content = content;
            holder.nodeIdTokenStart = content.indexOf(this.getNodeIdTokenStartString());
            holder.nodeId = parseNodeIdFromElement(holder, this.getNodeIdTokenStartString());
            return holder;
        }

        /**
         * Gets a node id from any string (usually SVG id or class attributes).
         *
         * @return -1 if {@link SvgElementHolder#nodeIdTokenStart} is -1 or if fails to find a numeric node id. Otherwise
         *         returns the node id
         */
        private String parseNodeIdFromElement(SvgElementHolder element, String tokenStartString)
        {
            if (element.nodeIdTokenStart != -1) {
                String nodeIdString = "";
                int readingPosition = element.nodeIdTokenStart + tokenStartString.length();
                Character idChar = element.content.charAt(readingPosition);
                while (Character.isDigit(idChar)) {
                    nodeIdString += idChar;
                    readingPosition++;
                    idChar = element.content.charAt(readingPosition);
                }
                if (StringUtils.isNotBlank(nodeIdString)) {
                    return nodeIdString;
                }
            }
            return null;
        }
    }

    private interface SvgElementParser
    {
        List<String> getSvgTagOpen();

        List<String> getSvgTagClosed();

        boolean test(String testPiece);

        boolean testHolder(SvgElementHolder holder);

        void iterativeAdd(int start, String svg, int offset, int nextSubstringStart,
            List<SvgElementHolder> elementList);
    }

    private static class SvgUpdateAction implements SvgAction
    {
        @Override
        public String getReplacement(SvgElementHolder holder)
        {
            return holder.content;
        }
    }

    private static class SvgRemoveAction implements SvgAction
    {
        @Override
        public String getReplacement(SvgElementHolder holder)
        {
            return "";
        }
    }

    private interface SvgAction
    {
        String getReplacement(SvgElementHolder holder);
    }
}
