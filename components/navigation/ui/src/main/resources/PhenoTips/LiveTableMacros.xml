<?xml version="1.0" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/
-->

<xwikidoc version="1.1">
  <web>PhenoTips</web>
  <name>LiveTableMacros</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>PhenoTips.WebHome</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title/>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>false</hidden>
  <content>{{velocity output="false"}}
## Additional XClasses that have been brought into the query, excluding the main class type which is used by default for properties.
## If a property ("propname") comes from a different XClass, a "propname/class" parameter with the XClass name ("Space.ClassName") as the value must be present in the request.
#set ($extraClassesAddedToQuery = {})

#**
 * Macro to get the results of a livetable data call.
 * This page is called from live grids via Ajax with the argument xpage=plain. It returns a
 * set of results serialized in JSON.
 *#
#macro(gridresult $className $collist)
  #gridresultwithfilter($className $collist "$!{request.filterFrom}" "$!{request.filterWhere}" [])
#end


#**
 * Computes the query used to retrieve the results of a live table data call.
 * NOTE: This macro is not fully encapsulated because it defines a few Velocity variables that are used in subsequent macros.
 *#
#macro(gridresultwithfilter_buildQuery $className $collist $filterfrom $filterwhere $filterParams)
  ## Additional columns; should *not* contain raw parameters, all added column names must be filtered
  #set($fromSql = '')
  ## Parametrized filter part of the query
  #set($whereSql = '')
  ## List of values to use with $whereSql
  #set($whereParams = [])
  ## The default XClass used for otherwise unbound property names; the main type of object queried by the livetable
  #if ("$!{className}" != '')
    #set ($class = $xwiki.getDocument($className).getxWikiClass())
  #else
    #set ($class = $NULL)
  #end
  ##
  ## Add the columns needed for the actual data
  ##
  #set($tablelist = [])
  #set ($processedColumns = $collectionstool.set)
  #foreach($colname in $request.parameterNames)
    #livetable_addColumnToQuery($colname)
  #end
  ##
  ##
  ## Order
  ##
  #set($order = "$!request.sort")
  #if($order != '')
    #set($orderDirection = "$!{request.get('dir').toLowerCase()}")
    #if("$!orderDirection" != '' &amp;&amp; "$!orderDirection" != 'asc')
      #set($orderDirection = 'desc')
    #end
    #set($tableAlias = $order)
    ## Only safe version should be used in SQL queries
    #set($safe_tableAlias = "$!{tableAlias.replaceAll('[^a-zA-Z0-9_.]', '')}")
    ##
    #if($order.startsWith('doc.'))
      #set($orderSql = " order by ${safe_tableAlias.replace('_','.')} ${orderDirection}")
    #elseif($tablelist.contains($tableAlias))
      #set ($multiselect = "$!{class.get($order).getProperty('multiSelect').getValue()}")
      #if ($multiselect != '1')
        #set ($orderSql = " order by ${safe_tableAlias}.value ${orderDirection}")
      #end
    #else
      #livetable_selectTargetObject($order true)
      #set($multiselect = $propClass.get($order).getProperty('multiSelect').getValue())
      #if("$multiselect" != '1')
        #livetable_getTableName($order)
        #set($fromSql = "${fromSql}, ${tableName} ${safe_tableAlias}")
        ## FIXME: Check if this is indeed a property of the class
        #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.name = ?")
        #set($discard = $whereParams.add("${order}"))
        #set($orderSql = " order by ${safe_tableAlias}.value ${orderDirection}")
      #end
    #end
  #end
  ##
  ##
  ## Compute the final queries
  ##
  #set($sqlParams = [])
  #set($tagsMatchingParams = [])
  #set($allMatchingParams = [])
  #if("$!className" != '')
    ## Class query
    #set($countSql = ", BaseObject as obj $!fromSql $!filterfrom where obj.name=doc.fullName and obj.className = ? and doc.fullName not in (?, ?) $!whereSql $!filterwhere")
    #set($discard = $sqlParams.addAll(["${className}", "${className}Template", ${className.replaceAll('Class$', 'Template')}]))
    #set($discard = $sqlParams.addAll($whereParams))
    ##
    #if($filterParams)
      #set($discard = $sqlParams.addAll($filterParams))
      #set($discard = $tagsMatchingParams.addAll($filterParams))
      #set($discard = $allMatchingParams.addAll($filterParams))
    #end
  #else
    ## Document query
    #set($countSql = "$!fromSql $!filterfrom where 1=1 $!whereSql $!filterwhere")
    #set($discard = $sqlParams.addAll($whereParams))
    ##
    #if($filterParams)
      #set($discard = $sqlParams.addAll($filterParams))
      #set($discard = $tagsMatchingParams.addAll($filterParams))
      #set($discard = $allMatchingParams.addAll($filterParams))
    #end
  #end
  #set($sql = "$countSql $!{orderSql}")
#end


#**
 * Adds information about each live table row to the JSON returned by a live table data call.
 * NOTE: This macro uses Velocity variables defined by gridresultwithfilter_buildQuery.
 *
 * @param $map stores the JSON in memory so that it can be adjusted before serialization
 *#
#macro(gridresult_buildRowsJSON $map)
  #set($offset = $mathtool.toInteger($request.get('offset')))
  ## Offset starts from 0 in velocity and 1 in javascript
  #set($offset = $offset - 1)
  #if (!$offset || $offset &lt; 0)
    #set($offset = 0)
  #end
  #set($limit = $mathtool.toInteger($request.get('limit')))
  #if (!$limit)
    #set ($limit = 15)
  #end
  #set($query = $services.query.hql($sql).addFilter('hidden').addFilter('unique').setLimit($limit).setOffset($offset).bindValues($sqlParams))
  #set($items = $query.execute())
  #set($discard = $map.put('totalrows', $query.count()))
  #set($discard = $map.put('returnedrows', $mathtool.min($items.size(), $limit)))
  #set($discard = $map.put('offset', $mathtool.add($offset, 1)))
  #set($rows = [])
  #foreach($item in $items)
    #gridresult_buildRowJSON($item $rows)
  #end
  #set($discard = $map.put('rows', $rows))
#end


#**
 * Adds information about the specified live table row to the JSON returned by a live table data call.
 * NOTE: This macro uses Velocity variables available in gridresult_buildRowsJSON.
 *
 * @param $item the name of the document that feeds this live table row
 * @param $rows stores the JSON in memory so that it can be adjusted before serialization
 *#
#macro(gridresult_buildRowJSON $item $rows)
  #set($viewable = $xwiki.hasAccessLevel('view', $xcontext.user, "${xcontext.database}:${item}"))
  #set($row = {'doc_viewable': $viewable})
  #if(!$viewable)
    #set($discard = $row.put('doc_fullName', "${xcontext.database}:${item}"))
  #else
    #set($itemDoc = $xwiki.getDocument($item))
    #set($fullname = $services.model.serialize($itemDoc.documentReference, 'default'))
    #set($discard = $itemDoc.use($className))
    #set($discard = $row.put('doc_name', $itemDoc.name))
    #set($discard = $row.put('doc_fullName', $fullname))
    #set($discard = $row.put('doc_space', $itemDoc.space))
    #set($discard = $row.put('doc_url', $xwiki.getURL($item)))
    #set($discard = $row.put('doc_space_url', $xwiki.getURL($services.model.createDocumentReference($!itemDoc.wiki, $!itemDoc.space, 'WebHome'))))
    #set($discard = $row.put('doc_wiki', $itemDoc.wiki))
    #set($discard = $row.put('doc_wiki_url', $xwiki.getURL($services.model.resolveDocument('', 'default', $itemDoc.documentReference.extractReference('WIKI')))))
    #set($discard = $row.put('doc_hasadmin', $xwiki.hasAdminRights()))
    #set($discard = $row.put('doc_hasedit', $xwiki.hasAccessLevel('edit', $xcontext.user, $fullname)))
    #set($discard = $row.put('doc_hasdelete', $xwiki.hasAccessLevel('delete', $xcontext.user, $fullname)))
    #set($discard = $row.put('doc_edit_url', $itemDoc.getURL($itemDoc.defaultEditMode)))
    #set($discard = $row.put('doc_copy_url', $itemDoc.getURL('view', 'xpage=copy')))
    #set($discard = $row.put('doc_delete_url', $itemDoc.getURL('delete')))
    #set($discard = $row.put('doc_rename_url', $itemDoc.getURL('view', 'xpage=rename&amp;step=1')))
    #set($discard = $row.put('doc_rights_url', $itemDoc.getURL('edit', 'editor=rights')))
    #set($discard = $row.put('doc_export_url', $itemDoc.getURL('export', "format=xar&amp;name=$!{itemDoc.fullName}&amp;pages=$!{itemDoc.fullName}")))
    #set($discard = $row.put('doc_history_url', $itemDoc.getURL('view', 'viewer=history')))
    #set($discard = $row.put('doc_author_url', $xwiki.getURL($itemDoc.author)))
    #set($discard = $row.put('doc_date', $xwiki.formatDate($itemDoc.date)))
    #set($discard = $row.put('doc_title', $escapetool.xml($itemDoc.plainTitle)))
    #set($discard = $row.put('doc_author', $services.xml.unescape($xwiki.getUserName($itemDoc.author, false))))
    #set($discard = $row.put('doc_creationDate', $xwiki.formatDate($itemDoc.creationDate)))
    #set($discard = $row.put('doc_creator', $services.xml.unescape($xwiki.getUserName($itemDoc.creator, false))))
    #set($discard = $row.put('doc_creator_url', $xwiki.getURL($itemDoc.creator)))
    #foreach($colname in $collist)
      #gridresult_buildColumnJSON($colname $row)
    #end
  #end
  #set($discard = $rows.add($row))
#end

#**
 * Formats the displayed value of a field
 *
 * @param $propMeta the xclass propery information for the field to display in a certain livetable column
 * @param $displayValue the value as it would be displayed in HTML
 *#
#macro(gridresult_formatFieldDisplay $propMeta $displayValue)
  ## Custom displayers generate HTML, TextAreas do the same, and there's a default custom displayer for String fields
  #if ($propMeta.getProperty('customDisplay').value != '' || $!propMeta.getClassType() == 'TextArea' || $!propMeta.getClassType() == 'String')
$!services.rendering.render($services.rendering.parse($displayValue, 'html/4.01'), 'plain/1.0')
  #else
$!displayValue
  #end
#end

#**
 * Adds information about the given column to the JSON returned by a live table data call.
 * NOTE: This macro uses Velocity variables available in gridresult_buildRowJSON.
 *
 * @param $colname the name of the live table column for which to retrieve information
 * @param $row stores the JSON in memory so that it can be adjusted before serialization
 *#
#macro(gridresult_buildColumnJSON $colname $row)
  #if($colname.startsWith('doc.'))
  #elseif($colname == '_action')
    #set($discard = $row.put($colname, $services.localization.render("${request.transprefix}actiontext")))
  #else
    #set($propClassName = "$!request.get($colname.concat('/class'))")
    #if($propClassName != '')
      #set($propClass = $xwiki.getDocument($propClassName).getxWikiClass())
      #set($discard = $itemDoc.use($propClassName))
    #else
      #set($propClass = $class)
    #end
    ## Retrieve the property type as it might be usefull
    #set($propType = '')
    #if($propClass.getPropertyNames().contains($colname))
      #set($propType = "$!propClass.get($colname).type")
    #end
    #set($fieldUrl = '')
    #if ($itemDoc.getObjects($propClassName).size() &gt; 1)
      #set ($fieldValue = [])
      #set($fieldDisplayValue = '')
      #foreach ($o in $itemDoc.getObjects($propClassName))
        #set ($discard = $fieldValue.add($o.getValue($colname)))
        #set ($onefieldDisplayValue = "#gridresult_formatFieldDisplay($propClass.get($colname), $itemDoc.display($colname, 'view', $o))")
        #if ($onefieldDisplayValue != '')
          #set ($fieldDisplayValue = $fieldDisplayValue.concat($onefieldDisplayValue.replaceFirst($regextool.quote('{{html clean="false" wiki="false"}}'), '').replaceAll("$regextool.quote('{{/html}}')$", '').trim()).concat(', '))
        #end
      #end
      #if($fieldDisplayValue == '')
        #set($fieldDisplayValue = $services.localization.render("${request.transprefix}emptyvalue"))
      #else
        #set($fieldDisplayValue = $fieldDisplayValue.substring(0, $fieldDisplayValue.lastIndexOf(',')))
      #end
    #else
      #set($fieldValue = "$!itemDoc.getValue($colname)")
      #set($fieldDisplayValue = "#gridresult_formatFieldDisplay($propClass.get($colname), $!itemDoc.display($colname, 'view'))")
      #if($fieldDisplayValue == '')
        #set($fieldDisplayValue = $services.localization.render("${request.transprefix}emptyvalue"))
      #end
      ## Only retrieve an URL for a DBListClass or PageClass item, with single values, or for the special case of document reference fields
      #if(($propType == 'DBListClass' || $propType == 'PageClass' || $request.getParameter("${colname}/match") == 'fullReference') &amp;&amp; $propClass.get($colname).getProperty('multiSelect').value != 1 &amp;&amp; "$fieldValue" != '')
        #set($fieldUrl = $xwiki.getURL($fieldValue))
        #if($fieldUrl == $xwiki.getURL($services.model.resolveDocument('', 'default', $doc.documentReference.extractReference('WIKI'))))
          #set($fieldUrl = '')
        #end
      #end
    #end
    #set($discard = $row.put($colname, $fieldDisplayValue.replaceFirst($regextool.quote('{{html clean="false" wiki="false"}}'), '').replaceAll("$regextool.quote('{{/html}}')$", '')))
    #set($discard = $row.put("${colname}_value", $fieldValue))
    #set($discard = $row.put("${colname}_url", $fieldUrl))
    ## Reset to the default class
    #set($discard = $itemDoc.use($className))
  #end
#end


#**
 * Builds the JSON response to a live table data call.
 *
 * @param $map stores the JSON in memory so that it can be adjusted before serialization
 *#
#macro(gridresultwithfilter_buildJSON $className $collist $filterfrom $filterwhere $filterParams $map)
  #gridresultwithfilter_buildQuery($className $collist $filterfrom $filterwhere $filterParams)
  #if("$!request.sql" == '1')
    #set($discard = $map.put('sql', $sql))
    #set($discard = $map.put('countsql', $countSql))
    #set($discard = $map.put('params', $sqlParams))
  #end
  #set($discard = $map.put('reqNo', $mathtool.toInteger($request.reqNo)))
  #gridresult_buildRowsJSON($map)
#end


#**
 * Builds the JSON response to a live table data call.
 *
 * @param $map stores the JSON in memory so that it can be adjusted before serialization
 *#
#macro(gridresult_buildJSON $className $collist $map)
  #gridresultwithfilter_buildJSON($className $collist '' '' [] $map)
#end


#**
 * Macro to get the results of a livetable data call.
 * This page is called from live grids via Ajax with the argument xpage=plain. It returns a
 * set of results serialized in JSON.
 *#
#macro(gridresultwithfilter $className $collist $filterfrom $filterwhere $filterParams)
  #if($xcontext.action == 'get' &amp;&amp; "$!{request.outputSyntax}" == 'plain')
    $response.setContentType('application/json')
    ## Build the JSON in memory (using basic Java data types) so that it can be adjusted before serialization.
    #set($map = {})
    #gridresultwithfilter_buildJSON($className $collist $filterfrom $filterwhere $filterParams $map)
    $jsontool.serialize($map)
  #end
#end


#**
 * Get the name of the Property that should be used for a given livetable column.
 * NOTE the resulting $tableName is safe to use inside SQL queries
 *#
#macro(livetable_getTableName $colname)
  #set($propClassName = "$!request.get(${colname.concat('/class')})")
  #if($propClassName != '')
    #set($propClass = $xwiki.getDocument($propClassName).getxWikiClass())
  #else
    #set($propClass = $class)
  #end
  #set($propType = '')
  #if($propClass.getPropertyNames().contains($colname))
    #set($propType = "$!{propClass.get($colname).type}")
  #end
  #if($propType == 'NumberClass')
    #set($numberType = $propClass.get($colname).getProperty('numberType').getValue())
    #if($numberType == 'integer')
      #set($tableName = 'IntegerProperty')
    #elseif($numberType == 'float')
      #set($tableName = 'FloatProperty')
    #elseif($numberType == 'double')
      #set($tableName = 'DoubleProperty')
    #else
      #set($tableName = 'LongProperty')
    #end
  #elseif($propType == 'BooleanClass')
    #set($tableName = 'IntegerProperty')
  #elseif($propType == 'DateClass')
    #set($tableName = 'DateProperty')
  #elseif($propType == 'TextAreaClass' || $propType == 'UsersClass' || $propType == 'GroupsClass')
    #set($tableName = 'LargeStringProperty')
  #elseif($propType == 'StaticListClass' || $propType == 'DBListClass' || $propType == 'DBTreeListClass')
    #set($multiSelect = $propClass.get($colname).getProperty('multiSelect').getValue())
    #set($relationalStorage = $propClass.get($colname).getProperty('relationalStorage').getValue())
    #if($multiSelect == 1)
      #if($relationalStorage == 1)
        #set($tableName = 'DBStringListProperty')
      #else
        #set($tableName = 'StringListProperty')
      #end
    #else
      #set($tableName = 'StringProperty')
    #end
  #else
    #set($tableName = 'StringProperty')
  #end
#end

#macro(livetable_selectTargetObject $colname $forceFilter)
  #set($propClassName = "$!request.get(${colname.concat('/class')})")
  #set ($targetedObject = 'obj')
  #if($propClassName != '')
    #set ($propClass = $xwiki.getDocument($propClassName).getxWikiClass())
    #if ($propClass &amp;&amp; $propClass.getPropertyNames().contains($colname) &amp;&amp; !$extraClassesAddedToQuery.containsKey($propClassName) &amp;&amp; $forceFilter)
      ## Additional decision: if the property is Boolean, and the filter value is 0, then the query will be a "not exists", so we don't need to add the object to the "from" part
      #set($propType = "$!{propClass.get($colname).type}")
      #if (!($propType == 'BooleanClass' &amp;&amp; ($filterValue == '0' || $filterValue == '-1')))
        #set ($targetedObject = "extraobj${extraClassesAddedToQuery.size()}")
        #set ($discard = $extraClassesAddedToQuery.put($propClassName, $targetedObject))
        #set ($fromSql = "${fromSql}, BaseObject ${targetedObject}")
        #set ($whereSql = "${whereSql} and ${targetedObject}.className = ? and ${targetedObject}.name = doc.fullName")
        #set ($discard = $whereParams.add($propClassName))
      #end
    #end
    #set ($targetedObject = $extraClassesAddedToQuery.get($propClassName))
  #else
    #set($propClass = $class)
  #end
#end

#**
 * Macro to extend the query to select the properties for the livetable columns.
 * NOTE $colname is filtered (all characters but [a-zA-Z0-9_.] are removed) before use
 *#
#macro(livetable_addColumnToQuery $colname)
 ## Safe because / is not allowed in property names
 #set ($colname = $stringtool.substringBefore($colname, '/'))
 #if ($processedColumns.add($colname))
  #set ($filterValue = "$!{request.get($colname)}")
  #set ($filterValueList = [])
  #foreach ($i in $request.getParameterValues($colname))
    #if ("$!i" != '')
      #set ($discard = $filterValueList.add($i))
    #end
  #end
  ## High/Low value filters (currently used for dates and numbers)
  #set ($filterValueLowLimit = "$!{request.get(""${colname}/after"")}$!{request.get(""${colname}/min"")}")
  #set ($filterValueHighLimit = "$!{request.get(""${colname}/before"")}$!{request.get(""${colname}/max"")}")
  #set($tableAlias = $colname)
  ## only safe versions should be used in SQL queries
  #if (!$filterValueList &amp;&amp; "$filterValueLowLimit$filterValueHighLimit" == '')
    #break($macro)
  #end
  #set($safe_colname = "$!{colname.replaceAll('[^a-zA-Z0-9_.]','')}")
  #set($safe_tableAlias = "$!{tableAlias.replaceAll('[^a-zA-Z0-9_.]','')}")
  ##
  #set($propType = '')
  #set($propertyHasFilterValue = "$!stringtool.join($filterValueList, '')" != '' || "$!filterValueLowLimit" != '' || "$!filterValueHighLimit" != '')
  #if ("$!request.getParameter($colname.concat('/dependsOn'))" != '' &amp;&amp; "$!stringtool.join($request.getParameterValues($!request.getParameter($colname.concat('/dependsOn'))), '')" == '')
    #set($propertyHasFilterValue = false)
  #end
  #livetable_selectTargetObject($colname $propertyHasFilterValue)
  #if($propClass &amp;&amp; $propClass.getPropertyNames().contains($colname))
    #set($propType = "$!{propClass.get($colname).type}")
  #elseif (!$colname.startsWith('doc.'))
    #break($macro)
  #end
  ##
  ## Filter values
  #if($propertyHasFilterValue)
    #set($discard = $tablelist.add($tableAlias))
    ##
    ## Document dates
    #if($colname.startsWith('doc.') &amp;&amp; ($colname.endsWith('Date') || $colname.endsWith('date')))
      #if ($filterValue != '')
        ## Exact filter, substring matching
        #set($whereSql = "${whereSql} and upper(str(${safe_tableAlias})) like upper(?) ESCAPE '!'")
        #set($discard = $whereParams.add("%${filterValue.replaceAll('[\[_%!]', '!$0')}%"))
      #else
        ## Before and After filters
        #if ($filterValueLowLimit != '')
          #set($whereSql = "${whereSql} and ${safe_tableAlias} &gt;= ?")
          #set($discard = $whereParams.add($services.jodatime.getDateTimeFormatterForPattern('MM/dd/yyyy').parseMutableDateTime($filterValueLowLimit).toDate()))
        #end
        #if ($filterValueHighLimit != '')
          #set($whereSql = "${whereSql} and ${safe_tableAlias} &lt; ?")
          #set($filterValueHighLimit = $services.jodatime.getDateTimeFormatterForPattern('MM/dd/yyyy').parseMutableDateTime($filterValueHighLimit))
          #set($discard = $filterValueHighLimit.addDays(1))
          #set($discard = $whereParams.add($filterValueHighLimit.toDate()))
        #end
      #end
    ##
    ## Document authors, exact match if the filter value contains a wiki or a space name, substring matches otherwise
    #elseif($colname == 'doc.creator' || $colname == 'doc.author')
      #foreach ($filterValue in $filterValueList)
        #if ($foreach.index == 0)
          #set ($whereSql = "${whereSql} and (")
        #else
          #set ($whereSql = "${whereSql} or")
        #end
        #if ($filterValue.startsWith('XWiki.'))
          #set($whereSql = "${whereSql} ${colname} = ?")
          #set($discard = $whereParams.add("${filterValue}"))
        #elseif ($filterValue.contains(':'))
          #set($whereSql = "${whereSql} ${colname} = ?")
          #set($discard = $whereParams.add("${stringtool.substringAfter($filterValue, ':')}"))
        #else
          #set($whereSql = "${whereSql} upper(str(${safe_colname.replace('_','.')})) like upper(?) ESCAPE '!'")
          #set($discard = $whereParams.add("%${filterValue.replaceAll('[\[_%!]', '!$0')}%"))
        #end
        #if (!$foreach.hasNext)
          #set ($whereSql = "${whereSql})")
        #end
      #end
    ##
    ## Other document fields, substring matching
    #elseif($colname.startsWith('doc.'))
      #set($whereSql = "${whereSql} and upper(str(${safe_colname.replace('_','.')})) like upper(?) ESCAPE '!'")
      #set($discard = $whereParams.add("%${filterValue.replaceAll('[\[_%!]', '!$0')}%"))
    ##
    ## Object properties from now on
    ##
    ## Numbers, exact match or min/max filters
    #elseif($propType == 'NumberClass')
      #livetable_getTableName($colname)
      #set($fromSql = "${fromSql}, ${tableName} ${safe_tableAlias}")
      #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ?")
      #set($discard = $whereParams.add("${colname}"))
      ## Converts each used value into correct type
      #set($numberType = $propClass.get($colname).getProperty('numberType').getValue())
      ##
      #if($numberType == 'integer' &amp;&amp; $filterValue.matches('\d*') &amp;&amp; $filterValueLowLimit.matches('\d*') &amp;&amp; $filterValueHighLimit.matches('\d*'))
        #set($typedFilterValue = $mathtool.toInteger($filterValue))
        #set($typedFilterValueLowLimit = $mathtool.toInteger($filterValueLowLimit))
        #set($typedFilterValueHighLimit = $mathtool.toInteger($filterValueHighLimit))
      #elseif($numberType == 'long' &amp;&amp; $filterValue.matches('\d*') &amp;&amp; $filterValueLowLimit.matches('\d*') &amp;&amp; $filterValueHighLimit.matches('\d*'))
        #set($typedFilterValue = $mathtool.toDouble($filterValue).longValue().valueOf($filterValue))
        #set($typedFilterValueLowLimit = $mathtool.toDouble($filterValueLowLimit).longValue().valueOf($filterValueLowLimit))
        #set($typedFilterValueHighLimit = $mathtool.toDouble($filterValueHighLimit).longValue().valueOf($filterValueHighLimit))
      #elseif($numberType == 'float' &amp;&amp; $filterValue.matches('\d*\.?\d*') &amp;&amp; $filterValueLowLimit.matches('\d*\.?\d*') &amp;&amp; $filterValueHighLimit.matches('\d*\.?\d*'))
        #set($typedFilterValue = $mathtool.toDouble($filterValue).floatValue())
        #set($typedFilterValueLowLimit = $mathtool.toDouble($filterValueLowLimit).floatValue())
        #set($typedFilterValueHighLimit = $mathtool.toDouble($filterValueHighLimit).floatValue())
      #elseif($numberType == 'double' &amp;&amp; $filterValue.matches('\d*\.?\d*') &amp;&amp; $filterValueLowLimit.matches('\d*\.?\d*') &amp;&amp; $filterValueHighLimit.matches('\d*\.?\d*'))
        #set($typedFilterValue = $mathtool.toDouble($filterValue))
        #set($typedFilterValueLowLimit = $mathtool.toDouble($filterValueLowLimit))
        #set($typedFilterValueHighLimit = $mathtool.toDouble($filterValueHighLimit))
      #end
      ## Checks present filter value
      #if ("$!typedFilterValue" != '')
        #set($whereSql = "${whereSql} and ${safe_tableAlias}.value = ?")
        #set($discard = $whereParams.add($typedFilterValue))
      #else ## filters by min and max values
        #if ("$!typedFilterValueLowLimit" != '')
          #set($whereSql = "${whereSql} and ${safe_tableAlias}.value &gt;= ?")
          #set($discard = $whereParams.add($typedFilterValueLowLimit))
        #end
        #if ("$!typedFilterValueHighLimit" != '')
          #set($whereSql = "${whereSql} and ${safe_tableAlias}.value &lt;= ?")
          #set($discard = $whereParams.add($typedFilterValueHighLimit))
        #end
      #end
    #elseif($propType=='BooleanClass')
      #livetable_getTableName($colname)
      #if ($filterValue == '1')
        #set($fromSql = "${fromSql}, ${tableName} ${safe_tableAlias}")
        #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and ${safe_tableAlias}.value = ?")
        #set($discard = $whereParams.addAll(["${colname}", $mathtool.toInteger(${filterValue})]))
      #elseif ($filterValue == '0')
        #set($whereSql = "${whereSql} and not exists (from BaseObject extraboolobj, ${tableName} ${safe_tableAlias} where extraboolobj.name = doc.fullName and extraboolobj.className = '${propClass.name}' and extraboolobj.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and ${safe_tableAlias}.value = 1)")
        #set($discard = $whereParams.addAll(["${colname}"]))
      #end
      ## For all values, no filtering needed
    ##
    ## Dates, either substring or before/after filters
    #elseif($propType == 'DateClass')
      #set($fromSql = "${fromSql}, DateProperty ${safe_tableAlias}")
      #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ?")
      #set($discard = $whereParams.add("${colname}"))
      #if ($filterValue != '')
        ## Exact filter, substring matching
        #set($whereSql = "${whereSql} and upper(str(${safe_tableAlias}.value)) like upper(?) ESCAPE '!'")
        #set($discard = $whereParams.add("%${filterValue.replaceAll('[\[_%!]', '!$0')}%"))
      #else
        ## Before and After filters
        #if ($filterValueLowLimit != '')
          #set($whereSql = "${whereSql} and ${safe_tableAlias}.value &gt;= ?")
          #set($discard = $whereParams.add($services.jodatime.getDateTimeFormatterForPattern('MM/dd/yyyy').parseDateTime($filterValueLowLimit).toDate()))
        #end
        #if ($filterValueHighLimit != '')
          #set($whereSql = "${whereSql} and ${safe_tableAlias}.value &lt; ?")
          #set($filterValueHighLimit = $services.jodatime.getDateTimeFormatterForPattern('MM/dd/yyyy').parseMutableDateTime($filterValueHighLimit))
          #set($discard = $filterValueHighLimit.addDays(1))
          #set($discard = $whereParams.add($filterValueHighLimit.toDate()))
        #end
      #end
    ##
    ## Large text properties, substring match
    #elseif($propType == 'TextAreaClass' || $propType == 'UsersClass' || $propType == 'GroupsClass')
      #set($fromSql = "${fromSql}, LargeStringProperty ${safe_tableAlias}")
      #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and upper(${safe_tableAlias}.value) like upper(?) ESCAPE '!'")
      #set($discard = $whereParams.addAll(["${colname}", "%${filterValue.replaceAll('[\[_%!]', '!$0')}%"]))
    ##
    ## Lists, these can be stored in several ways
    #elseif($propType == 'StaticListClass' || $propType == 'DBListClass' || $propType == 'DBTreeListClass')
      #set($multiSelect = $propClass.get($colname).getProperty('multiSelect').getValue())
      #set($relationalStorage = $propClass.get($colname).getProperty('relationalStorage').getValue())
      #if($multiSelect == 1)
        #if($relationalStorage == 1)
          ##
          ## Multiselect and relational storage, multiple list items can be stored and filtered
          ## Exact match for every filter value
          ## Multiple values are combined with a configurable operator, by default AND
          #set ($joinOperator = "$!{request.get(""${colname}/join_mode"").toUpperCase()}")
          #if ($joinOperator != 'AND' &amp;&amp; $joinOperator != 'OR')
            #set ($joinOperator = 'AND')
          #end
          #foreach ($filterValue in $filterValueList)
            #if ($foreach.isFirst())
              #set ($fromSql = "${fromSql}, DBStringListProperty ${safe_tableAlias}")
              #set ($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and (")
              #if ($request.get("${colname}_subterms") == 'yes')
                #set ($discard = $whereParams.add("extended_${colname}"))
              #else
                #set ($discard = $whereParams.add("${colname}"))
              #end
            #else
              #set ($whereSql = "${whereSql} ${joinOperator}")
            #end
            #set ($whereSql = "${whereSql} ? in elements(${safe_tableAlias}.list)")
            #set ($discard = $whereParams.add("${filterValue}"))
            #if ($foreach.isLast())
              #set ($whereSql = "${whereSql})")
            #end
          #end
        #else
          ##
          ## Multiselect, but not relational storage, multiple values are stored in a large text
          ## Assumes that | is used as the value delimiter
          ## Exact match
          #set($fromSql = "${fromSql}, StringListProperty ${safe_tableAlias}")
          #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and concat('|', concat(upper(${safe_tableAlias}.textValue), '|')) like upper(?) ESCAPE '!'")
          #set($discard = $whereParams.addAll(["${colname}", "%|${filterValue.replaceAll('[\[_%!]', '!$0')}|%"]))
        #end
      ##
      ## No multiselect, just one value is stored
      ## Exact match
      #else
        #set ($joinOperator = "$!{request.get(""${colname}/join_mode"").toUpperCase()}")
        #if ($joinOperator != 'AND' &amp;&amp; $joinOperator != 'OR')
          #set ($joinOperator = 'AND')
        #end
        #foreach ($filterValue in $filterValueList)
          #if ($foreach.isFirst())
            #set ($fromSql = "${fromSql}, StringProperty ${safe_tableAlias}")
            #set ($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and (")
            #set ($discard = $whereParams.add("${colname}"))
          #else
            #set ($whereSql = "${whereSql} ${joinOperator}")
          #end
          #set ($whereSql = "${whereSql} ${safe_tableAlias}.value = ?")
          #set ($discard = $whereParams.add("${filterValue}"))
          #if ($foreach.isLast())
            #set ($whereSql = "${whereSql})")
          #end
        #end
      #end
    ##
    ## Simple string and multiple filter values, exact match on any of the filter values
    #elseif ($filterValueList.size() &gt; 1)
      #set($fromSql = "${fromSql}, StringProperty ${safe_tableAlias}")
      #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and ${safe_tableAlias}.value in (${stringtool.repeat('?', ', ', $filterValueList.size())})")
      #set($discard = $whereParams.add("${colname}"))
      #foreach ($value in $filterValueList)
        ## Some fields are always stored as full references, and the query may come as a partial reference
        #if ($request.getParameter("${colname}/match") == 'fullReference')
          #set($discard = $whereParams.add($services.model.serialize($services.model.resolveDocument($value), 'default')))
        #else
          #set($discard = $whereParams.add($value))
        #end
      #end
    ## Simple string and a single filter value, configurable type of match: exact (case sensitive), case insensitive, or case insensitive substring
    #else
      #set($fromSql = "${fromSql}, StringProperty ${safe_tableAlias}")
      #if ($request.getParameter("${colname}/match") == 'fullReference')
        #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and ${safe_tableAlias}.value = ?")
        #set($discard = $whereParams.addAll(["${colname}", $services.model.serialize($services.model.resolveDocument($filterValueList[0]), 'default')]))
      #elseif ($request.getParameter("${colname}/match") == 'exact')
        #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and ${safe_tableAlias}.value = ?")
        #set($discard = $whereParams.addAll(["${colname}", "${filterValueList[0]}"]))
      #elseif ($request.getParameter("${colname}/match") == 'ci')
        #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and upper(${safe_tableAlias}.value) = ?")
        #set($discard = $whereParams.addAll(["${colname}", "${filterValueList[0].toUpperCase()}"]))
      #else
        #set($whereSql = "${whereSql} and ${targetedObject}.id=${safe_tableAlias}.id.id and ${safe_tableAlias}.id.name = ? and upper(${safe_tableAlias}.value) like upper(?) ESCAPE '!'")
        #set($discard = $whereParams.addAll(["${colname}", "%${filterValueList[0].replaceAll('[\[_%!]', '!$0')}%"]))
      #end
    #end
  #end
 #end
#end

#** ******************************************************************************************** *#

#**
 * Macro to generate entity permissions query fragments
 *#
#macro(generateentitypermissions $queryFragments)
  #if ($xwiki.getDocument('PhenoTips.OwnerClass').isNew() || $hasAdmin)
    #set ($filterFrom = "")
    #set ($filterWhere = "")
  #elseif ($isGuest)
    #set ($filterFrom = ", BaseObject accessObj, StringProperty accessProp")
    #set ($filterWhere = "and accessObj.name = doc.fullName and accessProp.id.id = accessObj.id and accessObj.className = 'PhenoTips.OwnerClass' and (accessProp.value = '' or accessProp.value is null)")
  #else
    #set ($groups = [])
    #set ($toProcess = $collectionstool.queue)
    #if ($xcontext.userReference)
      #set ($discard = $groups.add($xcontext.userReference))
      #set ($discard = $toProcess.add($xcontext.userReference.toString()))
    #end
    #foreach ($iteration in [0..1000])
      #if ($toProcess.empty)
        #break
      #end
      #set ($item = $toProcess.poll())
      #foreach ($group in $xwiki.wrapDocs($xwiki.rightsmanager.getAllGroupsNamesForMember($item)))
        #set ($groupObj = $group.getObject('PhenoTips.PhenoTipsGroupClass'))
        #if (!$groupObj &amp;&amp; $group.documentReference.name.endsWith(' Managers'))
          #set ($group = $xwiki.getDocument($services.model.resolveDocument($stringtool.removeEnd($group.documentReference.name, ' Managers'), $group.documentReference.parent)))
          #set ($groupObj = $group.getObject('PhenoTips.PhenoTipsGroupClass'))
        #end
        #if (!$groupObj &amp;&amp; $group.documentReference.name.endsWith(' Administrators'))
          #set ($group = $xwiki.getDocument($services.model.resolveDocument($stringtool.removeEnd($group.documentReference.name, ' Administrators'), $group.documentReference.parent)))
          #set ($groupObj = $group.getObject('PhenoTips.PhenoTipsGroupClass'))
        #end
        #if ($groupObj &amp;&amp; !$groups.contains($group.documentReference.toString()))
          #set ($discard = $toProcess.add($group.documentReference.toString()))
          #set ($discard = $groups.add($escapetool.sql($group.documentReference.toString())))
        #end
      #end
    #end
    #set ($groups = "('${stringtool.join($groups, ""','"")}')")
    #set ($filterFrom = ", BaseObject accessObj, StringProperty accessProp")
    #set ($filterWhere = "and accessObj.name = doc.fullName and accessProp.id.id = accessObj.id and ((accessObj.className = 'PhenoTips.OwnerClass' and accessProp.value in ${groups}) or (accessObj.className = 'PhenoTips.CollaboratorClass' and accessProp.value in ${groups}) or (accessObj.className = 'PhenoTips.VisibilityClass' and accessProp.value in ('public', 'open')))")
  #end
  #set ($discard = $queryFragments.put('from', "$!{filterFrom}"))
  #set ($discard = $queryFragments.put('where', "$!{filterWhere}"))
#end

#**
 * Macro to get the complete list of results matching the specified filters.
 * This page is called via Ajax with the argument xpage=plain. It returns a
 * set of results serialized in a JSONArray of strings, each string being a
 * document reference.
 *#
#macro(listresultwithfilter $className $filterfrom $filterwhere $filterParams)
  #set($list = [])
  #listresultwithfilter_buildList($className $filterfrom $filterwhere $filterParams $list)
  $jsontool.serialize($list)
#end

#**
 * Macro to get the complete list of results matching the specified filters.
 * The result is a list of strings, each string being a document reference,
 * which is placed in the $list parameter.
 *#
#macro(listresultwithfilter_buildList $className $filterfrom $filterwhere $filterParams $list)
  #gridresultwithfilter_buildQuery($className 'doc.name' $filterfrom $filterwhere $filterParams)
  #set($query = $services.query.hql($sql).addFilter('hidden').addFilter('unique').bindValues($sqlParams))
  #set($items = $query.execute())
  #foreach($item in $items)
    #set($discard = $list.add("${xcontext.database}:${item}"))
  #end
#end

#**
 * Macro to get the total number of results matching the specified filters.
 * This page is called via Ajax with the argument xpage=plain. It returns a
 * single number.
 *#
#macro(listresultwithfilterCount $className $filterfrom $filterwhere $filterParams)
  #gridresultwithfilter_buildQuery($className 'doc.name' $filterfrom $filterwhere $filterParams)
  #set($query = $services.query.hql($sql).addFilter('hidden').addFilter('unique').bindValues($sqlParams))
  $query.count()
#end

{{/velocity}}</content>
</xwikidoc>
